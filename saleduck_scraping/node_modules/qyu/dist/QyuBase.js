"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = void 0;
const qyu_error_1 = __importDefault(require("./qyu-error"));
const Deferred_1 = __importDefault(require("./utils/Deferred"));
const omitNilProps_1 = __importDefault(require("./utils/omitNilProps"));
class QyuBase {
    constructor(opts = {}) {
        Object.defineProperty(this, "isAtMaxConcurrency", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isRunningJobChannels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isPaused", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "opts", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "whenEmptyDeferred", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "whenFreeDeferred", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "jobChannels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "jobQueue", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.jobQueue = [];
        this.jobChannels = [];
        this.isAtMaxConcurrency = false;
        this.isRunningJobChannels = false;
        this.isPaused = false;
        this.whenEmptyDeferred = new Deferred_1.default();
        this.whenEmptyDeferred.resolve();
        this.whenFreeDeferred = new Deferred_1.default();
        this.whenFreeDeferred.resolve();
        this.opts = {
            concurrency: 1,
            capacity: Infinity,
            rampUpTime: 0,
            ...(0, omitNilProps_1.default)(opts),
        };
    }
    set(newOpts) {
        const oldOpts = this.opts;
        this.opts = {
            ...this.opts,
            ...(0, omitNilProps_1.default)(newOpts),
        };
        if (oldOpts.concurrency &&
            newOpts.concurrency &&
            newOpts.concurrency > oldOpts.concurrency) {
            this.runJobChannels();
        }
        if (newOpts.capacity) {
            while (this.jobQueue.length > newOpts.capacity) {
                this.jobQueue
                    .pop()
                    .deferred.reject(new qyu_error_1.default('ERR_CAPACITY_FULL', "Can't queue job, queue is at max capacity"));
            }
        }
    }
    add(jobFn, opts, ...jobArgs) {
        const enqueueOpts = {
            ...opts,
            args: jobArgs.length ? jobArgs : undefined,
        };
        return this.enqueue(jobFn, enqueueOpts);
    }
    map(iterable, iterableMapFn, opts) {
        let counter = 0;
        const promises = [];
        for (const item of iterable) {
            promises.push(this.add(iterableMapFn, opts, item, counter++));
        }
        return Promise.all(promises);
    }
    async pause() {
        if (this.isPaused) {
            return;
        }
        this.isPaused = true;
        if (!this.jobQueue.length && !this.jobChannels.length) {
            this.whenEmptyDeferred = new Deferred_1.default();
        }
        // TODO: return a promise that will resolve when current jobs that were already running will finish. Perhaps: return this.whenEmpty();
        await Promise.all(this.jobChannels);
    }
    resume() {
        if (!this.isPaused) {
            return;
        }
        this.isPaused = false;
        if (!this.jobQueue.length && !this.jobChannels.length) {
            this.whenEmptyDeferred.resolve();
        }
        this.runJobChannels();
    }
    empty() {
        for (const job of this.jobQueue.splice(0)) {
            job.deferred.reject(new qyu_error_1.default('ERR_JOB_DEQUEUED', 'Job was dequeued out of the queue'));
            guardUnhandledPromiseRejections(job);
        }
        return Promise.all(this.jobChannels);
    }
    whenEmpty() {
        return this.whenEmptyDeferred.promise;
    }
    whenFree() {
        return this.whenFreeDeferred.promise;
    }
    enqueue(fn, opts = {}) {
        var _a, _b;
        const job = {
            fn,
            opts: {
                timeout: (_a = opts.timeout) !== null && _a !== void 0 ? _a : 0,
                priority: (_b = opts.priority) !== null && _b !== void 0 ? _b : 0,
                args: opts.args,
            },
            deferred: new Deferred_1.default(),
            timeoutId: undefined,
        };
        if (this.jobQueue.length === this.opts.capacity) {
            job.deferred.reject(new qyu_error_1.default('ERR_CAPACITY_FULL', "Can't queue job, queue is at max capacity"));
            guardUnhandledPromiseRejections(job);
            return job.deferred.promise;
        }
        if (opts.timeout) {
            job.timeoutId = setTimeout(() => {
                this.dequeue(job.deferred.promise);
                job.timeoutId = undefined;
                job.deferred.reject(new qyu_error_1.default('ERR_JOB_TIMEOUT', 'Job cancelled due to timeout'));
                guardUnhandledPromiseRejections(job);
            }, opts.timeout);
        }
        let i = 0;
        while (i < this.jobQueue.length &&
            job.opts.priority <= this.jobQueue[i].opts.priority) {
            ++i;
        }
        this.jobQueue.splice(i, 0, job);
        this.runJobChannels();
        return job.deferred.promise;
    }
    // TODO: Modify this function to return something more appropriate for publich exposure rather than the internal job structure, and add it a suitable return type annotation
    dequeue(promise) {
        for (let i = 0; i < this.jobQueue.length; ++i) {
            if (this.jobQueue[i].deferred.promise === promise) {
                const splice = this.jobQueue.splice(i, 1);
                return splice[0];
            }
        }
        return false;
    }
    async runJobChannel() {
        var _a;
        let job;
        while (!this.isPaused &&
            this.jobChannels.length <= this.opts.concurrency &&
            (job = this.jobQueue.shift())) {
            if (job.timeoutId) {
                clearTimeout(job.timeoutId);
            }
            try {
                const result = await job.fn.apply(undefined, (_a = job.opts.args) !== null && _a !== void 0 ? _a : []);
                job.deferred.resolve(result);
            }
            catch (err) {
                job.deferred.reject(err);
                guardUnhandledPromiseRejections(job);
            }
        }
    }
    async runJobChannels() {
        if (this.isRunningJobChannels) {
            return;
        }
        this.isRunningJobChannels = true;
        while (this.jobQueue.length &&
            !this.isPaused &&
            this.jobChannels.length < this.opts.concurrency) {
            (async () => {
                // TODO: Add additional condition here: "&& !this.jobQueue.length" for when pause() is engaged while there are still jobs in the jobQueue
                if (!this.jobChannels.length) {
                    this.whenEmptyDeferred = new Deferred_1.default();
                }
                if (this.jobChannels.length === this.opts.concurrency - 1) {
                    this.whenFreeDeferred = new Deferred_1.default();
                }
                const promise = this.runJobChannel();
                this.jobChannels.push(promise);
                await promise;
                this.jobChannels.splice(this.jobChannels.indexOf(promise), 1);
                if (this.jobChannels.length === this.opts.concurrency - 1) {
                    this.whenFreeDeferred.resolve();
                }
                // TODO: Add additional condition here: "&& !this.jobQueue.length" for when pause() is engaged while there are still jobs in the jobQueue
                if (!this.jobChannels.length && !this.isPaused) {
                    this.whenEmptyDeferred.resolve();
                }
            })();
            if (this.opts.rampUpTime && this.jobChannels.length) {
                await new Promise(resolve => setTimeout(resolve, this.opts.rampUpTime));
            }
        }
        this.isRunningJobChannels = false;
    }
}
exports.default = QyuBase;
const noop = (val) => val;
// To avoid "Unhandled promise rejections":
const guardUnhandledPromiseRejections = (jobObject) => {
    return jobObject.deferred.promise.catch(noop);
};
//# sourceMappingURL=QyuBase.js.map