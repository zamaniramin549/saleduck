import MaybePromise from './utils/MaybePromise';
declare class QyuBase {
    isAtMaxConcurrency: boolean;
    isRunningJobChannels: boolean;
    isPaused: boolean;
    opts: NormalizedQyuOptions;
    private whenEmptyDeferred;
    private whenFreeDeferred;
    private jobChannels;
    private jobQueue;
    constructor(opts?: QyuInputOptions);
    set(newOpts: QyuInputOptions): void;
    add<JobReturnVal, JobArgs extends any[]>(jobFn: JobFunction<JobReturnVal, JobArgs>, opts?: {
        timeout?: number | null | undefined;
        priority?: number | null | undefined;
    } | undefined | null, ...jobArgs: JobArgs): Promise<JobReturnVal>;
    map<IterableVal, JobReturnVal>(iterable: Iterable<IterableVal>, iterableMapFn: (item: IterableVal, idx: number) => MaybePromise<JobReturnVal>, opts?: {
        timeout?: number | null | undefined;
        priority?: number | null | undefined;
    } | undefined | null): Promise<JobReturnVal[]>;
    pause(): Promise<undefined | void>;
    resume(): undefined | void;
    empty(): Promise<void[]>;
    whenEmpty(): Promise<undefined | void>;
    whenFree(): Promise<undefined | void>;
    private enqueue;
    private dequeue;
    private runJobChannel;
    private runJobChannels;
}
declare type NormalizedQyuOptions = Required<{
    [K in keyof QyuInputOptions]: NonNullable<QyuInputOptions[K]>;
}>;
interface QyuInputOptions {
    concurrency?: number | undefined | null;
    capacity?: number | undefined | null;
    rampUpTime?: number | undefined | null;
}
declare type JobFunction<ReturnVal, Args extends unknown[]> = (...args: Args) => MaybePromise<ReturnVal>;
export { QyuBase as default, QyuInputOptions };
